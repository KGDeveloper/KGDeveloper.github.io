---
layout:     post
title:      iOS面试算法题收集
subtitle:   iOS面试算法题收集
date:       2020-12-10
author:     KG丿夏沫
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 面试题
    - 算法
---


# iOS面试算法题收集

一、给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，你可以假设每个输入只对应一种答案，且同样的元素不能重复利用。

>示例：

```
给定数组 NSArray *arr = @[2,7,11,15,20]; NSInteger target = 9;

因为 arr[0] + arr[1] = 9;

所以返回[0,1]
```

>解决思路：

```
1、首先肯定需要循环，第一层for循环，arr的下标为0，开始走，获取数组每个元素arr[i]
2、第二层for循环，从上层循环的i+1开始走，获取后面数据arr[j]，保证每次两层循环都不会拿到重复数据
3、arr[i]+arr[j]如果等于target，那就输出下标以及元素。
```

>OC示例代码

```
NSInteger target = 11;
NSArray *arr = @[@(2),@(11),@(7),@(9),@(0),@(3),@(6),@(1),@(8),@(5),@(4),@(111)];

for (int i = 0; i < arr.count; i++) {
    for (int j = i+1; j < arr.count; j++) {
        if ([arr[i] integerValue] + [arr[j] integerValue] == target) {
            NSLog(@"%@(%d) + %@(%d) = %ld\n",arr[i],i,arr[j],j,(long)target);
        }
    }
}
```

>输出结果：
```
2(0) + 9(3) = 11
11(1) + 0(4) = 11
7(2) + 4(10) = 11
3(5) + 8(8) = 11
6(6) + 5(9) = 11
```

二、给定两个非空链表，表示两个非负整数，位数按照逆序方式存储，他们的每个节点只存储单个数字，将两数相加，返回一个新的链表，你可以假设除了数字0之外,这2个数字都不会以零开头.

>示例：

```
NSArray *firstArr = @[@(2),@(4),@(3)];
NSArray *lastArr = @[@(5),@(6),@(4)];
输出[7,0,8]
```

>解决思路：

```
1、首先用两个数据表示链表，存储给定的数据
2、然后用两个NSInteger表示给定的数据
3、使用for循环倒序遍历计算给定的数据，并赋值给NSInteger
4、计算两个数的和，并使用一个NSInteger存储
5、创建一个数组，使用while循环，取余将余数添加到数组
6、输出数组
```

>OC示例代码

```
NSArray *starArr = @[@(2),@(4),@(3)];
NSArray *endArr = @[@(5),@(6),@(4)];
NSMutableArray *resArr = [NSMutableArray array];

NSInteger starInt = 0;
NSInteger endInt = 0;
NSInteger result = 0;
for (NSInteger i = starArr.count-1; i >= 0; i--) {
    starInt = starInt*10+[starArr[i] integerValue];
}
for (NSInteger i = endArr.count-1; i >= 0; i--) {
    endInt = endInt*10+[endArr[i] integerValue];
}

result = starInt+endInt;

while (result>9) {
    [resArr addObject:@(result%10)];
    result = (result-(result%10))/10;
}

[resArr addObject:@(result)];

if ([resArr[0] integerValue] == 0) {
    [resArr removeObjectAtIndex:0];
}
```

>输出结果

```
342 + 465 = 807
(7,0,8)
```
三、给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。

>解决思路

```
1、先进行数据转换，因为不确定是正整数还是负整数
2、然后从转换后的整数从后取值，赋给新值，能保证是倒叙
3、每次赋值时原先基础上乘十然后加上新值，保证新值永远在个位数增加
4、倒叙结束后，判断初始值是负整数还是正整数，加上符号
5、判断是否超出限制区间，如果超出直接返回0
```
>Swift示例代码:

```
class Solution {
    func reverse(_ x: Int) -> Int {
        
        var res:Int = 0;
        var tmp = abs(x);
        
        while tmp > 0 {
            res = res*10 + tmp%10;
            tmp = tmp/10
        }
        
        if x < 0 {
            res = 0 - res;
        }
        
        if ((-1<<31 <= res) && (res <= (1<<31-1)))  {
            return res;
        }else{
            return 0;
        }
    }
}
```
>输出结果: 

```
-321
```
四、给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

>解决思路：

```
1、先判断是否是负数，如果是负数直接返回false
2、先进行数据转换，因为不确定是正整数还是负整数
3、然后从转换后的整数从后取值，赋给新值，能保证是倒叙
4、每次赋值时原先基础上乘十然后加上新值，保证新值永远在个位数增加
5、然后判断是否在运行区间内，如果不在直接返回false
6、判断是否相等
```

>Swift代码示例:

```
class Solution {
    func isPalindrome(_ x: Int) -> Bool {
        if x < 0 {
            return false;
        }

        var res:Int = 0;
        var tmp = abs(x);

        while tmp > 0 {
            res = res*10 + tmp%10;
            tmp = tmp/10
        }
        
        if ((-1<<31 <= res) && (res <= (1<<31-1)))  {
            return res == x;
        }else{
            return false;
        }
    }
}
```

五、罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
>
>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
>
>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

>解决思路：

```
1、首先将给定字符串切割成单个字符，加入到数组中
2、遍历过程中取出数组最后一个字符，判断是否比当前的小，如果小那就移除之前的，添加差值
3、遍历数组中的值进行累加
```

>Swift代码示例：

```
class Solution {
    func romanToInt(_ s: String) -> Int {
        
        let arr:NSMutableArray = NSMutableArray();
        
        for tmp:Character in s {
            let str = String.init(tmp)
            var currValue = 0;
            if str.elementsEqual("I") {
                currValue = 1;
            }else if str.elementsEqual("V") {
                currValue = 5;
            }else if str.elementsEqual("X") {
                currValue = 10;
            }else if str.elementsEqual("L") {
                currValue = 50;
            }else if str.elementsEqual("C") {
                currValue = 100;
            }else if str.elementsEqual("D") {
                currValue = 500;
            }else if str.elementsEqual("M") {
                currValue = 1000;
            }
            if arr.count > 0 {
                let leftvalue:Int = arr[arr.count-1] as! Int;
                if leftvalue < currValue {
                    arr.removeLastObject();
                    arr.add((currValue-leftvalue))
                }else{
                    arr.add(currValue)
                }
            }else{
                arr.add(currValue)
            }
        }
        
        var res = 0;
        
        for index in 0..<arr.count {
            let leftvalue:Int = arr[index] as! Int
            res += leftvalue
        }
        
        return res
    }
}
```
六、编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

>解决思路:

```
1、先计算最小字符串长度
2、按照最小字符串进行遍历，从每个字符串0个开始去字符比较
3、如果字符都有，拼接到公共开头字符串中
4、如果出现不一致的开头直接返回，先前结果
```
>Swift示例代码：

```
class Solution {
    func longestCommonPrefix(_ strs: [String]) -> String {
        var minStr:Int = 200
        
        for str in strs {
            if str.lengthOfBytes(using: String.Encoding.utf8) < minStr {
                minStr = str.lengthOfBytes(using: String.Encoding.utf8)
            }
        }
        
        var res = ""
        
        for index in 0..<minStr {
            var tmpRes = ""
            var count = 0
            
            for str in strs {
                if tmpRes == "" {
                    tmpRes = String.init(str[String.Index(encodedOffset: index)])
                }
                
                if String.init(str[String.Index(encodedOffset: index)]) != tmpRes {
                    count += 1
                }
            }
            
            if (tmpRes != "" && count == 0) {
                res += tmpRes
            }else{
                return res
            }
        }
        return res
    }
}
```
七、给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：
>1、左括号必须用相同类型的右括号闭合。
>
>2、左括号必须以正确的顺序闭合。

>解决思路

```
1、传入的字符串是否有效在于括号是否对应，所以创建一个数组，将字符串从头开始遍历，遇到括号就添加，每次添加前先判断数组是否为空，如果为空直接添加，如果不为空取最后一个进行判断是否是和当前括号对应
2、如果数组最后一个括号与当前的对应，那么就删除数组最后一个值，当前值不做添加操作
3、就是遇到左括号就往数组中添加，遇到右括号，就取数组最后一个值，看是否对应，如果对应就解，如果不对应，继续添加
4、最后判断数组是否为空来确定是否符合，为空表示有效
```
>Swift示例代码

```
class Solution {
    func isValid(_ s: String) -> Bool {
        let arr:NSMutableArray = NSMutableArray()
        
        for char in s {
            if arr.count > 0 {
                if String(char) == foundValidValue(arr.lastObject as! String) {
                    arr.removeLastObject()
                }else{
                    arr.add(String(char))
                }
            }else{
                arr.add(String(char))
            }
        }
        return arr.count==0
    }
    
    func foundValidValue(_ s:String) -> String {
        if s == "(" {
            return ")"
        }else if s == "[" {
            return "]"
        }else if s == "{"  {
            return "}"
        }else{
            return ""
        }
    }
}
```
八、将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

<img src="../img/20210519001.png"/>

>解决思路

```
1、先判断是否为空，如果有空直接根据条件，返回相应值
2、做递归进行判断，左侧链表的值大还是右侧链表值大，将小的值赋值个新链表当前节点，next值递归
```
>Swift示例代码

```
public class ListNode {
    public var val:Int
    public var next:ListNode?
    public init() {
        self.val = 0;
        self.next = nil;
    }
    public init(_ val:Int){
        self.val = val;
        self.next = nil;
    }
    public init(_ val:Int,_ next:ListNode?){
        self.val = val;
        self.next = next;
    }
}

class Solution {
    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        let list = ListNode.init()
        if l1 == nil && l2 != nil {
            return l2
        }
        if l2 == nil && l1 != nil{
            return l1
        }
        if l1 == nil && l2 == nil {
            return nil
        }
        if l1!.val > l2!.val {
            list.val = l2!.val
            if l2?.next == nil {
                list.next = l1
            }else{
                list.next = mergeTwoLists(l1, l2?.next)
            }
        }else{
            list.val = l1!.val
            if l1?.next == nil {
                list.next = l2
            }else{
                list.next = mergeTwoLists(l1?.next, l2)
            }
        }
        return list
    }
    
    func compareTwoLists(_ arr:NSMutableArray) -> ListNode? {
        let list = ListNode.init()
        if arr.count > 0 {
            list.val = arr.firstObject as! Int;
            arr.remove(arr.firstObject as Any)
            if arr.count > 0 {
                list.next = compareTwoLists(arr)
            }
            return list
        }else{
            return nil
        }
    }
}
```
九、给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

####说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
>解决思路

```
1、首先判断数组是否为空，为空直接返回0
2、数组不为空的情况下，至少有一个不重复的元素
3、因为数组是有序的数组，所以只需要判断相邻元素是否相同，如果发现不相同的元素，往前移动，使用一个值来记录移动的元素个数
4、最后得到的移动元素个数值就是新数组长度
```
>Swift示例代码

```
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        if nums.count == 0 {
            return 0
        }
        
        var fast = 1
        var slow = 1
        
        while fast < nums.count {
            if nums[fast] != nums[fast-1] {
                nums[slow] = nums[fast]
                slow += 1
            }
            fast += 1
        }
        return slow
    }
}
```

十、给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
####说明:
为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
>解决思路

```
1、首先判断数组是否为空，为空直接返回0
2、因为给定了需要移除的元素，所以只需要遍历数组，找到相同元素进行移除，但是如果用for循环，遍历过程中数组长度发生变化容易跳过相邻元素的比对，所以使用while循环，使用外部值，当找到需要删除元素时，对查找的下标指针进行减一操作，防止跳过元素检查
3、最后遍历结束后得到的数组就是去除给定元素后的新数组
```

>Swift示例代码

```
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        if nums.count == 0 {
            return 0
        }
        
        var fast = 0
        while fast < nums.count {
            if nums[fast] == val {
                nums.remove(at: fast)
                fast -= 1
            }
            fast += 1
        }
        return nums.count
    }
}
```
十一、实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
####说明：
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。

>解决思路

```
1、首先读懂题意，查找字符串中是否包含某个字符串
2、当存在时返回第一次出现的字符串所在部分开头下标
3、如果指定字符串为空，返回0
4、如果需要目标字符串为空，返回-1
5、两个字符串长度不能超过50000
6、根据以上结果，先进行条件判断，不满足条件的直接根据相应要求返回对应状态
7、在字符串中查找，最快方法从字符串开头位置移动指针，根据指针偏移量以及查找字符串的长度，截取字符串比较是否相等，如果相等直接返回指针对应的下标
```
>Swift示例代码

```
class Solution {
    func strStr(_ haystack: String, _ needle: String) -> Int {
        
        if needle.lengthOfBytes(using: String.Encoding.utf8) == 0 {
            return 0
        }
        
        if haystack.lengthOfBytes(using: String.Encoding.utf8) == 0 {
            return -1
        }
        
        if haystack.lengthOfBytes(using: String.Encoding.utf8) > 5*10000 {
            return -1
        }
        
        if needle.lengthOfBytes(using: String.Encoding.utf8) > 5*10000 {
            return -1
        }
        
        if needle.lengthOfBytes(using: String.Encoding.utf8) == haystack.lengthOfBytes(using: String.Encoding.utf8) {
            if needle == haystack {
                return 0
            }else{
                return -1
            }
        }
        
        var fast = 0
        
        while fast < haystack.lengthOfBytes(using: String.Encoding.utf8) {
            if (fast + needle.lengthOfBytes(using: String.Encoding.utf8)) <= haystack.lengthOfBytes(using: String.Encoding.utf8) {
                let starIndex = haystack.index(haystack.startIndex,offsetBy: fast)
                let endIndex = haystack.index(haystack.startIndex,offsetBy: fast+needle.lengthOfBytes(using: String.Encoding.utf8)-1)
                let str = haystack[starIndex...endIndex]
                if str == needle {
                    return fast
                }
            }
            fast += 1
        }
        
        return -1
    }
}
```
十二、给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。

>解决思路

```
1、首先确定数组是通过排序的，所以只需要遍历一次就可以确定有没有，如果没有应该放在哪个位置
2、当我们遍历的时候，先判断是否相等，来确定是否包含，然后判断是否遍历的当前值是否大于给定值，如果大于，就说明数组中不包含给定值，我们就将给定值插入到当前值的前面，下标就是当前值的原下标
3、如果遍历完数组后，还是没有找到，那就说明给定值比数组中的任何一个值都大，所以直接添加到数组结尾，下标为原数组长度值
```
>Swift示例代码

```
class Solution {
    func searchInsert(_ nums: [Int], _ target: Int) -> Int {
        if nums.count == 0 {
            return 0
        }
        var fast = 0
        while fast < nums.count {
            if nums[fast] == target {
                return fast
            }
            if nums[fast] > target {
                return fast
            }
            fast += 1
        }
        return nums.count
    }
}
```
十三、给定一个正整数 n ，输出外观数列的第 n 项。「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。你可以将其视作是由递归公式定义的数字字符串序列：

```
countAndSay(1) = "1"
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
```
前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
```
要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 "3322251" 的描述如下图：

<img src="../img/20210519002.png"/>

>解决思路

```
1、首先理解题意，根据传入的整型，做外观队列，即（整型控制循环次数，每次循环对从1开始的字符串进行描述）
2、理解题意后，进行外层循环，这个循环用给定的整型控制
3、内部循环中使用一个字符串记录每一次循环结束后记录本次的描述，作为下一次的初始值
4、依次进行循环，直到达到边界
```
>Swift示例代码

```
class Solution {
    func countAndSay(_ n: Int) -> String {
        
        if n == 1 {
            return "1"
        }
        
        if n == 0 {
            return ""
        }
        
        var val = 1;
        var str = "1";
        
        while val < n {
            let tmp = str
            var tmpRes = ""
            var count = 0
            var ch:Character = "A"
            for char in tmp {
                if ch == "A" {
                    ch = char
                }
                if char == ch {
                    count += 1
                }else{
                    tmpRes += String(count)+String(ch)
                    ch = char
                    count = 1
                }
            }
            tmpRes += String(count)+String(ch)
            str = tmpRes
            val += 1
        }
        return String(str)
    }
}
```
十四、给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

>解决思路

```
1、数组不是有序的，而且有正整数和负整数，并不限制数组长度
2、首先过滤元素是否满足条件
3、通过移动数组两边的指针，然后对区间内的元素进行累加，取最大值输出
```
>Swift示例代码

```
class Solution {
    func maxSubArray(_ nums: [Int]) -> Int {
        
        if nums.count == 1 {
            return nums[0]
        }
        
        if nums.count == 0 {
            return 0
        }
        
        if nums.count > 30000 {
            return 0
        }
        
        var sum = -100000
        
        for i in 0..<nums.count {
            if nums[i] > 100000 || nums[i] < -100000 {
                return 0
            }
            var j = nums.count-1
            var tmpSum = 0
            while j >= i {
                for index in i...j {
                    tmpSum += nums[index]
                    if tmpSum > sum {
                        sum = tmpSum
                    }
                    j -= 1
                }
            }
        }
        return sum
    }
}
```
十五、给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

>解决思路

```
1、根据题意，字符串只包含空格以及英文字母，所以不需要去过滤
2、判断字符串是否为空，如果为空直接返回0
3、判断字符串中是否全部为空格，如果是，返回0
4、将字符串以空格进行切割，合法字符串切割成数组后，数组至少包含一个元素，直接获取最后一个元素，返回其长度就OK了
```
>Swift示例代码

```
class Solution {
    func lengthOfLastWord(_ s: String) -> Int {
        
        let arr = s.split(separator: " ")
        
        if arr.count == 1 {
            return arr[0].lengthOfBytes(using: String.Encoding.utf8)
        }
        if arr.count == 0 {
            return 0
        }
        
        if s.lengthOfBytes(using: String.Encoding.utf8) > 10000 {
            return 0
        }
        
        return arr[arr.count-1].lengthOfBytes(using: String.Encoding.utf8)
    }
}
```
十六、给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。

>解决思路

```
1、数组是非空，元素是正整数以及0
2、数组是表示一个完整的整数
3、得到数组表示的整数后进行加1操作
4、然后将加1后的数组，转换成数组输出
```
>Swift示例代码

```
class Solution {
    func plusOne(_ digits: [Int]) -> [Int] {
        
        if digits.count > 100 {
            return []
        }
        
        var sum = ""
        
        for index in 0..<digits.count {
            if digits[index] > 10 {
                return []
            }
            sum += String(digits[index])
        }
        
        var last = sum.removeLast()
        var addStr = ""
        
        while Int(String(last))! == 9 {
            addStr += "0"
            if sum.lengthOfBytes(using: String.Encoding.utf8) > 0 {
                last = sum.removeLast()
            }else{
                last = "0"
            }
        }
        
        sum += String(Int(String(last))!+1) + addStr
        
        let arr:NSMutableArray = NSMutableArray()
        
        last = sum.removeFirst()
        
        while sum.lengthOfBytes(using: String.Encoding.utf8) > 0 {
            arr.add(Int(String(last))!)
            last = sum.removeFirst()
        }
        arr.add(Int(String(last))!)
        return arr as! [Int]
    }
}
```
十七、

>解决思路

```
```
>Swift示例代码

```
```
十八、

>解决思路

```
```
>Swift示例代码

```
```
十九、

>解决思路

```
```
>Swift示例代码

```
```
二十、

>解决思路

```
```
>Swift示例代码

```
```