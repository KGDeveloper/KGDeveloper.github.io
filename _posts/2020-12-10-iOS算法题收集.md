---
layout:     post
title:      iOS面试算法题收集
subtitle:   iOS面试算法题收集
date:       2020-12-10
author:     KG丿夏沫
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 面试题
    - 算法
---


# iOS面试算法题收集

一、给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，你可以假设每个输入只对应一种答案，且同样的元素不能重复利用。

>示例：

```
给定数组 NSArray *arr = @[2,7,11,15,20]; NSInteger target = 9;

因为 arr[0] + arr[1] = 9;

所以返回[0,1]
```

>解决思路：

```
1、首先肯定需要循环，第一层for循环，arr的下标为0，开始走，获取数组每个元素arr[i]
2、第二层for循环，从上层循环的i+1开始走，获取后面数据arr[j]，保证每次两层循环都不会拿到重复数据
3、arr[i]+arr[j]如果等于target，那就输出下标以及元素。
```

>OC示例代码

```
NSInteger target = 11;
NSArray *arr = @[@(2),@(11),@(7),@(9),@(0),@(3),@(6),@(1),@(8),@(5),@(4),@(111)];

for (int i = 0; i < arr.count; i++) {
    for (int j = i+1; j < arr.count; j++) {
        if ([arr[i] integerValue] + [arr[j] integerValue] == target) {
            NSLog(@"%@(%d) + %@(%d) = %ld\n",arr[i],i,arr[j],j,(long)target);
        }
    }
}
```

>输出结果：
```
2(0) + 9(3) = 11
11(1) + 0(4) = 11
7(2) + 4(10) = 11
3(5) + 8(8) = 11
6(6) + 5(9) = 11
```

二、给定两个非空链表，表示两个非负整数，位数按照逆序方式存储，他们的每个节点只存储单个数字，将两数相加，返回一个新的链表，你可以假设除了数字0之外,这2个数字都不会以零开头.

>示例：

```
NSArray *firstArr = @[@(2),@(4),@(3)];
NSArray *lastArr = @[@(5),@(6),@(4)];
输出[7,0,8]
```

>解决思路：

```
1、首先用两个数据表示链表，存储给定的数据
2、然后用两个NSInteger表示给定的数据
3、使用for循环倒序遍历计算给定的数据，并赋值给NSInteger
4、计算两个数的和，并使用一个NSInteger存储
5、创建一个数组，使用while循环，取余将余数添加到数组
6、输出数组
```

>OC示例代码

```
NSArray *starArr = @[@(2),@(4),@(3)];
NSArray *endArr = @[@(5),@(6),@(4)];
NSMutableArray *resArr = [NSMutableArray array];

NSInteger starInt = 0;
NSInteger endInt = 0;
NSInteger result = 0;
for (NSInteger i = starArr.count-1; i >= 0; i--) {
    starInt = starInt*10+[starArr[i] integerValue];
}
for (NSInteger i = endArr.count-1; i >= 0; i--) {
    endInt = endInt*10+[endArr[i] integerValue];
}

result = starInt+endInt;

while (result>9) {
    [resArr addObject:@(result%10)];
    result = (result-(result%10))/10;
}

[resArr addObject:@(result)];

if ([resArr[0] integerValue] == 0) {
    [resArr removeObjectAtIndex:0];
}
```

>输出结果

```
342 + 465 = 807
(7,0,8)
```
三、给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。

>解决思路

```
1、先进行数据转换，因为不确定是正整数还是负整数
2、然后从转换后的整数从后取值，赋给新值，能保证是倒叙
3、每次赋值时原先基础上乘十然后加上新值，保证新值永远在个位数增加
4、倒叙结束后，判断初始值是负整数还是正整数，加上符号
5、判断是否超出限制区间，如果超出直接返回0
```
>Swift示例代码:

```
class Solution {
    func reverse(_ x: Int) -> Int {
        
        var res:Int = 0;
        var tmp = abs(x);
        
        while tmp > 0 {
            res = res*10 + tmp%10;
            tmp = tmp/10
        }
        
        if x < 0 {
            res = 0 - res;
        }
        
        if ((-1<<31 <= res) && (res <= (1<<31-1)))  {
            return res;
        }else{
            return 0;
        }
    }
}
```
>输出结果: 

```
-321
```
四、给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

>解决思路：

```
1、先判断是否是负数，如果是负数直接返回false
2、先进行数据转换，因为不确定是正整数还是负整数
3、然后从转换后的整数从后取值，赋给新值，能保证是倒叙
4、每次赋值时原先基础上乘十然后加上新值，保证新值永远在个位数增加
5、然后判断是否在运行区间内，如果不在直接返回false
6、判断是否相等
```

>Swift代码示例:

```
class Solution {
    func isPalindrome(_ x: Int) -> Bool {
        if x < 0 {
            return false;
        }

        var res:Int = 0;
        var tmp = abs(x);

        while tmp > 0 {
            res = res*10 + tmp%10;
            tmp = tmp/10
        }
        
        if ((-1<<31 <= res) && (res <= (1<<31-1)))  {
            return res == x;
        }else{
            return false;
        }
    }
}
```

五、罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
>
>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
>
>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

>解决思路：

```
1、首先将给定字符串切割成单个字符，加入到数组中
2、遍历过程中取出数组最后一个字符，判断是否比当前的小，如果小那就移除之前的，添加差值
3、遍历数组中的值进行累加
```

>Swift代码示例：

```
class Solution {
    func romanToInt(_ s: String) -> Int {
        
        let arr:NSMutableArray = NSMutableArray();
        
        for tmp:Character in s {
            let str = String.init(tmp)
            var currValue = 0;
            if str.elementsEqual("I") {
                currValue = 1;
            }else if str.elementsEqual("V") {
                currValue = 5;
            }else if str.elementsEqual("X") {
                currValue = 10;
            }else if str.elementsEqual("L") {
                currValue = 50;
            }else if str.elementsEqual("C") {
                currValue = 100;
            }else if str.elementsEqual("D") {
                currValue = 500;
            }else if str.elementsEqual("M") {
                currValue = 1000;
            }
            if arr.count > 0 {
                let leftvalue:Int = arr[arr.count-1] as! Int;
                if leftvalue < currValue {
                    arr.removeLastObject();
                    arr.add((currValue-leftvalue))
                }else{
                    arr.add(currValue)
                }
            }else{
                arr.add(currValue)
            }
        }
        
        var res = 0;
        
        for index in 0..<arr.count {
            let leftvalue:Int = arr[index] as! Int
            res += leftvalue
        }
        
        return res
    }
}
```
六、编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

>解决思路:

```
1、先计算最小字符串长度
2、按照最小字符串进行遍历，从每个字符串0个开始去字符比较
3、如果字符都有，拼接到公共开头字符串中
4、如果出现不一致的开头直接返回，先前结果
```
>Swift示例代码：

```
class Solution {
    func longestCommonPrefix(_ strs: [String]) -> String {
        var minStr:Int = 200
        
        for str in strs {
            if str.lengthOfBytes(using: String.Encoding.utf8) < minStr {
                minStr = str.lengthOfBytes(using: String.Encoding.utf8)
            }
        }
        
        var res = ""
        
        for index in 0..<minStr {
            var tmpRes = ""
            var count = 0
            
            for str in strs {
                if tmpRes == "" {
                    tmpRes = String.init(str[String.Index(encodedOffset: index)])
                }
                
                if String.init(str[String.Index(encodedOffset: index)]) != tmpRes {
                    count += 1
                }
            }
            
            if (tmpRes != "" && count == 0) {
                res += tmpRes
            }else{
                return res
            }
        }
        return res
    }
}
```