---
layout:     post
title:      Block
subtitle:   Block
date:       2021-03-29
author:     KG丿夏沫
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - OC
    - 笔记
    - Block
---

# Block

<img src="https://raw.githubusercontent.com/KGDeveloper/KGImg/master/img/20210329001.png?token=AHPRJRCCMP5CVGPA62676PDAMFWRS" alt="Block图解"/>

### Block定义以及表达式

在iOS开发中针对于Objective-C我们经常提到Block，对于Swift来说就是闭包，今天主要是探索Block，所以先有个疑问，什么是Block？为什么要用Block？
>首先Block是一个OC对象，其内部也是isa指针，Block封装了函数实现以及函数上下文的OC对象

>使用Block是为了将函数的调用以及实现合并到一起

Block的声明：```返回值(^Block名称)(参数列表){Block回调实现}```

Block的调用：```Block名称(Block参数)```

### Block分类

在我们程序运行过程中，Block的使用是非常广泛的，比如数组遍历```enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {}```，masonry等很多优秀三方库中也会发现Block的身影，所以我们探索下的使用场景以及在什么场景下Block是什么类型

在我们iOS系统中Block分为6种：
>_NSConcreteStackBlock：栈Block
>
>_NSConcreteMallocBlock：堆Block
>
>_NSConcreteGlobalBlock：全局Block
>
>_NSConcreteAutoBlock：在GC环境下，当对象被```__weak，__block```修饰，并且从栈复制到堆时，block会被标记为该模式
>
>_NSConcreteFinalizingBlock：在GC环境下，当block被复制时，如果block有ctors&dtors时，则转换为该模式
>
>_NSConcreteWeakBlockVariable：与```_NSConcreteFinalizingBlock```反之则转换为该模式

### Block的结构

Block作为一个OC的对象，是一个结构体类型，其结构如下：

```
struct Block_layout {
    void *isa;
    volatile int32_t flags;
    int32_t reserved;
    BlockInvokeFunction invoke;
    struct Block_descriptor_1 *descriptor;
};
```
知识点：

>1、通过上面Block的结构体，就能得出我们之所以说Block也是OC对象的原因，因为Block内部也有isa指针

>2、其中用到了一个修饰符```volatile```这个在系统结构体里面很常见，这个修饰符的意思就是告诉编译器，我修饰的属性，不需要你去优化，包括存储的空间也不需要你去优化。而且```volatile```修饰符保证了不同线程对这个属性进行操作的时候的可见性，即一个线程修改了变量的值，这个新值对其他线程来说是立即可见的。

### Block源码探索

首先下载[block源码](https://opensource.apple.com/source/libclosure/libclosure-78/)，然后我们打开项目后，然后创建一个```TARGET```，然后打开```main.m```文件，在里面申明并调用简单的block，代码如下：

```
int main() {
    void(^block0)(void) = ^{
        NSLog(@"==================\n");
    };
    block0();
}
```
然后在block申明处添加断点，同时打开汇编模式，运行程序，然后进入断点后，点击```step over```然后会发现进入了```_Block_copy```函数，然后打开源码，找到```_Block_copy```函数的实现，代码如下：

```
// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.
// 拷贝 block，
// 如果原来就在堆上，就将引用计数加 1;
// 如果原来在栈上，会拷贝到堆上，引用计数初始化为 1，并且会调用 copy helper 方法（如果存在的话）；
// 如果 block 在全局区，不用加引用计数，也不用拷贝，直接返回 block 本身
// 参数 arg 就是 Block_layout 对象，
// 返回值是拷贝后的 block 的地址
void *_Block_copy(const void *arg) {
    struct Block_layout *aBlock;

    // 如果 arg 为 NULL，直接返回 NULL
    if (!arg) return NULL;
    
    // The following would be better done as a switch statement
    // 强转为 Block_layout 类型
    aBlock = (struct Block_layout *)arg;
    // 获取Block签名
    const char *signature = _Block_descriptor_3(aBlock)->signature;
    
    // 如果现在已经在堆上
    if (aBlock->flags & BLOCK_NEEDS_FREE) {
        // latches on high
        // 就只将引用计数加 1
        latching_incr_int(&aBlock->flags);
        return aBlock;
    }
    // 如果 block 在全局区，不用加引用计数，也不用拷贝，直接返回 block 本身
    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
        return aBlock;
    }
    else {
        // Its a stack block.  Make a copy.
        // block 现在在栈上，现在需要将其拷贝到堆上
        // 在堆上重新开辟一块和 aBlock 相同大小的内存
        struct Block_layout *result =
            (struct Block_layout *)malloc(aBlock->descriptor->size);
        // 开辟失败，返回 NULL
        if (!result) return NULL;
        // 将 aBlock 内存上的数据全部复制新开辟的 result 上
        memmove(result, aBlock, aBlock->descriptor->size); // bitcopy first
#if __has_feature(ptrauth_calls)
        // Resign the invoke pointer as it uses address authentication.
        result->invoke = aBlock->invoke;
#endif
        // reset refcount
        // 将 flags 中的 BLOCK_REFCOUNT_MASK 和 BLOCK_DEALLOCATING 部分的位全部清为 0
        result->flags &= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    // XXX not needed
        // 将 result 标记位在堆上，需要手动释放；并且引用计数初始化为 1
        result->flags |= BLOCK_NEEDS_FREE | 2;  // logical refcount 1
        // copy 方法中会调用做拷贝成员变量的工作
        _Block_call_copy_helper(result, aBlock);
        // Set isa last so memory analysis tools see a fully-initialized object.
        // isa 指向 _NSConcreteMallocBlock
        result->isa = _NSConcreteMallocBlock;
        return result;
    }
}
```
在这个函数中主要进行以下操作:

>1、进行强转，变成```Block_layout```结构体对象。
>
>2、然后调用```Block_descriptor_3```函数获取签名信息，在这个函数内部首先判断是否有签名信息，用到了Block给构体中```flags```属性，这个属性与```BLOCK_HAS_SIGNATURE```(1左移30位)进行或运算，然后判断结果是否为0，如果结果为0，那么表示没有签名信息，直接返回null，如果不为0，获取Block的```descriptor```指针，然后指针偏移```Block_descriptor_1```结构体大小，然后继续判断```flags```属性或运算```BLOCK_HAS_COPY_DISPOSE```(1左移25位)得到的结果是否为0，如果不为0，指针再次偏移```Block_descriptor_2```结构体大小，最后得到```Block_descriptor_3```的地址，然后进行强转后返回```Block_descriptor_3```对象，这样外部就可以直接访问到```Block_descriptor_3```结构体对象的属性。
>
>3、然后判断Block是否在堆上，如果在堆上Block的引用计数加1，然后返回Block对象
>
>4、如果Block是全局Block，不做任何处理直接返回Block对象
>
>5、如果Block是栈区Block，那么先在堆上开辟一块和Block大小相同的空间，如果开辟空间失败，直接返回null，如果开辟成功，直接将block的数据全部复制到新开辟的堆上block，重新定义调用指针。然后将堆上block的flags中的BLOCK_REFCOUNT_MASK 和 BLOCK_DEALLOCATING 部分的位全部清为 0，然后标记堆block并且引用计初始化为1，然后调用```_Block_call_copy_helper```方法，复制栈block的属性到堆block上，修改堆block的isa指针为堆block类型。

### Block实现以及变量捕获

我们都知道Block会捕获外部变量，那么是怎么捕获的，Block在编译时发生了什么？怎么找到外部变量的？怎么找到Block块的实现的？