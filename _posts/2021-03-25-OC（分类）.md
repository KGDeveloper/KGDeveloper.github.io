---
layout:     post
title:      OC（分类）
subtitle:   OC（分类）
date:       2021-03-25
author:     KG丿夏沫
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - OC
    - 笔记
    - 分类
---

#  OC分类

### 一、分类的作用

>对现有已存在的类添加方法，但是不想在现有类中进行修改，如果团队开发，直接在现有类中进行修改，会导致别人的代码出现bug或者其他意外，所以有了分类。

>#### 疑问：

>>1、分类中能否添加成员变量？

>>>	首先分类中没有isa指针，而且在objc源码中查看分类的结构体时会发现，并没有存储成员变量的列表。所以没有办法给分类添加成员变量

>>2、分类中能否添加属性？

>>> 分类中可以添加属性，系统会给我们声明setter以及getter方法，但是在setter和getter方法里面并没有进行赋值以及取值操作，所以正常理论上来说是不能添加属性的。但是结合runtime就可以实现给分类添加属性，runtime有两个API可以辅助我们实现```id objc_getAssociatedObject(id object, const void *key)```实现取值，```void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)```赋值。如下示例：

>>> ```
>>> #import "LGPerson.h"
>>> NS_ASSUME_NONNULL_BEGIN
>>> 
>>> @interface LGPerson (KGPerson)
>>> 
>>> @property (nonatomic,copy) NSString *name;
>>> 
>>> @end
>>> 
>>> NS_ASSUME_NONNULL_END
>>> ```
>>> 
>>> ```
>>> #import "LGPerson+KGPerson.h"
>>>#import <objc/runtime.h>
>>>
>>>static NSString *nameKey = @"NAME_KEY";
>>>
>>>@implementation LGPerson (KGPerson)
>>>
>>>- (NSString *)name{
>>>    return objc_getAssociatedObject(self, &nameKey);
>>>}
>>>
>>>- (void)setName:(NSString *)name{
>>>    objc_setAssociatedObject(self, &nameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);
>>>}
>>>
>>>@end
>>> ```

### 二、分类的结构体

```
struct category_t {
    const char *name;	//分类类名
    classref_t cls;		//具体含义不太清楚
    WrappedPtr<method_list_t, PtrauthStrip> instanceMethods; //对象方法列表
    WrappedPtr<method_list_t, PtrauthStrip> classMethods; //类方法列表
    struct protocol_list_t *protocols; //协议方法列表
    struct property_list_t *instanceProperties; //属性列表
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
    
    protocol_list_t *protocolsForMeta(bool isMeta) {
        if (isMeta) return nullptr;
        else return protocols;
    }
};
```

> 从以上分类的结构体可以看出，我们可以在分类中添加对象方法、类方法、协议以及属性，但是需要注意的就是系统只会生成setter和getter方法的声明，需要我们自己去实现setter和getter方法。
 
> 针对属性实现setter方法赋值和getter方法取值，我们考虑有哪些方法处理？如果有怎么实现，方案的缺点？

>>有如下几种方案：
>>
>>1、声明一个全局的变量。缺点：如果有多个有多个对象，就会共用一个全局变量，其中一个对象修改，所有对象的值都会改变。
>>
>>2、声明一个全局的字典存储。优点：避免了对象之间赋值相互影响问题。缺点：线程不安全
>>
>>3、使用runtime的api。优点：避免了对象之间赋值相互影响问题。
>>

>#### 疑问：在分类中添加的方法以及属性那些，为什么我们在类对象中可以访问到？我们并没有去创建分类对象，怎么去访问到的？下面带着疑问开始重点Category分类的加载过程探索，

三、分类的加载过程

> 由于整个合并加载过程由runtime去完成，所以我们从runtime的初始化方法开始进行分析，以下是runtime的初始化方法。

```
void _objc_init(void)
{
    //使用静态变量确保该方法不会被重复执行
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    // 修复延迟初始化直到找到一个使用对象的图像?
    //初始化环境变量
    environ_init();
    //进行线程绑定
    tls_init();
    //调用C++静态构造函数
    static_init();
    //初始化runtime
    runtime_init();
    //初始化libobjc的异常处理系统。
    exception_init();
#if __OBJC2__
    //初始化缓存
    cache_t::init();
#endif
    _imp_implementationWithBlock_init();
    //注册函数通知(镜像的映射,加载,解除映射),在这里主要看map_images的实现
    _dyld_objc_notify_register(&map_images, load_images, unmap_image);

#if __OBJC2__
    didCallDyldNotifyRegister = true;
#endif
}
```
>从初始化方法中我们看到我们需要的Category的加载过程是在```void map_images(unsigned count, const char * const paths[],const struct mach_header * const mhdrs[])```中实现的，所以重点看下这个方法的实现。处理dyld映射到的给定图像
>
>```
void
map_images(unsigned count, const char * const paths[],
           const struct mach_header * const mhdrs[])
{
    //运行时锁定
    mutex_locker_t lock(runtimeLock);
    return map_images_nolock(count, paths, mhdrs);
}
>```
>
>然后调用```map_images_nolock```方法，我们继续往下查找。
>
>```
void 
map_images_nolock(unsigned mhCount, const char * const mhPaths[],
                  const struct mach_header * const mhdrs[])
{
    ...
    if (hCount > 0) {
        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);
    }
    ...
}
>```
>在这个方法里面经过一系列的处理，最后开始去读取镜像

